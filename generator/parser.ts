import type { FunctionDescriptor, FunctionArgument } from "./function-descriptor";
import { JSDOM } from 'jsdom';

// Lua reserved keywords that need to be renamed if used as parameter names
const LUA_RESERVED_KEYWORDS = new Set([
    'and', 'break', 'do', 'else', 'elseif', 'end', 'false', 'for',
    'function', 'if', 'in', 'local', 'nil', 'not', 'or', 'repeat',
    'return', 'then', 'true', 'until', 'while'
]);

export interface ParseResult {
    functions: Record<string, FunctionDescriptor>;
    version?: string;
}

function extractReaperVersion(document: Document): string | undefined {
    // Look for the version text in a table cell with font size="1"
    const fontElements = document.querySelectorAll('font[size="1"]');
    for (const font of fontElements) {
        const text = font.textContent?.trim();
        if (text && text.includes('Generated by REAPER v')) {
            const versionMatch = text.match(/Generated by REAPER v([\d.]+)/);
            if (versionMatch) {
                return versionMatch[1];
            }
        }
    }
    return undefined;
}

export async function parseContent(content: string): Promise<ParseResult> {
    const dom = new JSDOM(content);
    const document = dom.window.document;

    const functions: Record<string, FunctionDescriptor> = {};

    // Extract REAPER version
    const version = extractReaperVersion(document);

    // Find all Lua function divs
    const luaFunctionDivs = document.querySelectorAll('div.l_func');

    for (const luaDiv of luaFunctionDivs) {
        try {
            const functionDescriptor = parseLuaFunction(luaDiv, document);
            if (functionDescriptor) {
                functions[functionDescriptor.name] = functionDescriptor;
            }
        } catch (error) {
            console.warn(`Failed to parse function: ${error}`);
        }
    }

    // Also find special Lua functions with anchor-based format
    const specialLuaFunctions = parseSpecialLuaFunctions(document);

    // Merge with existing functions
    Object.assign(functions, specialLuaFunctions);

    return { functions, version };
}

function parseLuaFunction(luaDiv: Element, document: Document): FunctionDescriptor | null {
    // Get the code element containing the function signature
    const codeElement = luaDiv.querySelector('code');
    if (!codeElement) {
        return null;
    }

    const signature = codeElement.textContent?.trim();
    if (!signature) {
        return null;
    }

    // Extract function name and parameters from signature
    // Example: "boolean reaper.AudioAccessorValidateState(AudioAccessor accessor)"
    const functionMatch = signature.match(/reaper\.(\w+)\s*\((.*?)\)/);
    if (!functionMatch || !functionMatch[1] || functionMatch[2] === undefined) {
        return null;
    }

    const functionName = functionMatch[1];
    const parametersString = functionMatch[2].trim();

    // Extract return type (everything before "reaper.")
    const returnTypeMatch = signature.match(/^(.*?)\s+reaper\./);
    const returnType = returnTypeMatch && returnTypeMatch[1] ? returnTypeMatch[1].trim() : 'void';

    // Parse parameters
    const parameters = parseParameters(parametersString);

    // Parse return type
    const returns = parseReturnType(returnType);

    // Get description - look for the function anchor and description
    const description = getDescriptionForFunction(functionName, document);

    return {
        name: functionName,
        description,
        parameters,
        returns
    };
}

function getDescriptionForFunction(functionName: string, document: Document): string {
    // Find the anchor with the function name
    const anchor = document.querySelector(`a[name="${functionName}"]`);
    if (!anchor) {
        return '';
    }

    const window = document.defaultView;
    if (!window) {
        return '';
    }

    // Find the p_func div following this anchor
    let current = anchor.nextElementSibling;
    let pFuncDiv: Element | null = null;

    // Look for the p_func div that comes after this function's anchor
    while (current) {
        if (current.classList.contains('p_func')) {
            pFuncDiv = current;
            break;
        }
        current = current.nextElementSibling;
    }

    if (!pFuncDiv) {
        return '';
    }

    // Collect all text content until we hit the next function anchor
    const descriptionParts: string[] = [];
    let sibling = pFuncDiv.nextSibling;

    while (sibling) {
        if (sibling.nodeType === window.Node.TEXT_NODE) {
            const text = sibling.textContent?.trim();
            if (text) {
                descriptionParts.push(text);
            }
        } else if (sibling.nodeType === window.Node.ELEMENT_NODE) {
            const element = sibling as Element;

            // Stop if we hit the next function anchor
            if (element.tagName === 'A' && element.getAttribute('name')) {
                break;
            }

            // Stop if we hit major section dividers
            if (element.classList.contains('e_funcs') ||
                element.classList.contains('l_funcs') ||
                element.tagName === 'H2' ||
                (element.tagName === 'HR' && element.nextElementSibling?.tagName === 'H2')) {
                break;
            }

            // Skip br tags but collect text from other elements (like anchor tags)
            if (element.tagName !== 'BR') {
                // For anchor tags, get the inner text (link text)
                if (element.tagName === 'A') {
                    const linkText = element.textContent?.trim();
                    if (linkText) {
                        descriptionParts.push(linkText);
                    }
                } else {
                    // For other elements, check if they contain meaningful text
                    const text = element.textContent?.trim();
                    if (text && text.length > 5 &&
                        !element.classList.contains('c_func') &&
                        !element.classList.contains('e_func') &&
                        !element.classList.contains('l_func') &&
                        !element.classList.contains('p_func')) {
                        descriptionParts.push(text);
                    }
                }
            }
        }
        sibling = sibling.nextSibling;
    }

    // Join all parts and clean up
    const fullDescription = descriptionParts.join(' ');
    return fullDescription ? cleanDescriptionText(fullDescription) : '';
}

function sanitizeParameterName(name: string): string {
    // If the parameter name is a Lua reserved keyword, append an underscore
    if (LUA_RESERVED_KEYWORDS.has(name.toLowerCase())) {
        return `${name}_`;
    }
    return name;
}

function parseParameters(parametersString: string): FunctionArgument[] {
    if (!parametersString || parametersString.trim() === '') {
        return [];
    }

    const parameters: FunctionArgument[] = [];

    // Split by comma, but be careful of nested types
    const paramParts = parametersString.split(',').map(p => p.trim());

    for (const paramPart of paramParts) {
        if (!paramPart) continue;

        // Extract type and name
        // Example: "AudioAccessor accessor" or "number startTime"
        const paramMatch = paramPart.match(/^(.*?)\s+(\w+)$/);
        if (paramMatch && paramMatch[1] && paramMatch[2]) {
            const type = paramMatch[1].trim();
            let name = paramMatch[2].trim();

            name = sanitizeParameterName(name);

            parameters.push({
                name,
                value: '', // We don't have default values in the signature
                type: mapLuaType(type),
                required: true // Assume all parameters are required unless specified otherwise
            });
        }
    }

    return parameters;
}

function parseReturnType(returnType: string): FunctionArgument[] {
    if (!returnType || returnType === 'void') {
        return [];
    }

    // Handle complex return type strings like "boolean retval, boolean mute ="
    // Remove trailing equals and other non-type content
    const cleanReturnType = returnType.replace(/\s*=\s*$/, '').trim();

    // Split by commas to handle multiple return values
    const parts = cleanReturnType.split(',').map(part => part.trim());

    const returns: FunctionArgument[] = [];

    for (const part of parts) {
        if (!part) continue;

        // Extract type and name from patterns like "boolean retval" or "optional string info"
        const typeMatch = part.match(/^(optional\s+)?(\w+)(?:\s+(\w+))?$/);
        if (typeMatch && typeMatch[2]) {
            const isOptional = !!typeMatch[1];
            const type = typeMatch[2];
            const paramName = typeMatch[3] || 'return'; // Use captured name or default to 'return'

            returns.push({
                name: paramName,
                value: '',
                type: mapLuaType(type),
                required: !isOptional
            });
        } else {
            // Fallback: treat the whole part as a type if we can't parse it
            const simpleType = part.split(/\s+/)[0]; // Take first word as type
            if (simpleType) {
                returns.push({
                    name: 'return',
                    value: '',
                    type: mapLuaType(simpleType),
                    required: true
                });
            }
        }
    }

    return returns;
}

function mapLuaType(type: string): string {
    // Map HTML italic tags and clean up types
    const cleanType = type.replace(/<\/?i>/g, '').trim();

    // Map common types to more standard names
    const typeMap: Record<string, string> = {
        'boolean': 'boolean',
        'number': 'number',
        'string': 'string',
        'AudioAccessor': 'AudioAccessor',
        'MediaTrack': 'MediaTrack',
        'MediaItem': 'MediaItem',
        'Take': 'Take',
        'PCM_source': 'PCM_source',
        'reaper.array': 'ReaperArray'
    };

    return typeMap[cleanType] || cleanType;
}

function getDescription(luaDiv: Element): string {
    // Find the parent container and look for description text after all function divs
    let current = luaDiv.parentElement;
    if (!current) {
        return '';
    }

    const document = luaDiv.ownerDocument;
    const window = document.defaultView;
    if (!window) {
        return '';
    }

    // The description usually follows right after the last function div (p_func)
    // Let's walk through siblings looking for the p_func, then get the next text
    let pFuncDiv = current.parentElement?.querySelector('div.p_func');
    if (pFuncDiv) {
        // Look for text content after p_func div
        let sibling = pFuncDiv.nextSibling;
        while (sibling) {
            if (sibling.nodeType === window.Node.TEXT_NODE) {
                const text = sibling.textContent?.trim();
                if (text && text.length > 15) {
                    return cleanDescriptionText(text);
                }
            }
            sibling = sibling.nextSibling;
        }

        // If no direct text sibling, check the next element
        let nextElement = pFuncDiv.nextElementSibling;
        if (nextElement && !nextElement.querySelector('a[name]')) {
            const text = nextElement.textContent?.trim();
            if (text && text.length > 15) {
                return cleanDescriptionText(text);
            }
        }
    }

    // Fallback: look for any text after our lua div
    let sibling = luaDiv.nextSibling;
    while (sibling) {
        if (sibling.nodeType === window.Node.TEXT_NODE) {
            const text = sibling.textContent?.trim();
            if (text && text.length > 15) {
                return cleanDescriptionText(text);
            }
        }
        sibling = sibling.nextSibling;
    }

    return '';
}

function cleanDescriptionText(text: string): string {
    return text
        .replace(/\s+/g, ' ')
        .replace(/\.\s*<br.*?>/gi, '.')
        .replace(/<[^>]*>/g, '')
        .replace(/\s*\.\s*$/, '.')
        .trim();
}

function parseSpecialLuaFunctions(document: Document): Record<string, FunctionDescriptor> {
    const functions: Record<string, FunctionDescriptor> = {};

    // Find all anchors with lua_ prefix using a more generic approach
    const allAnchors = document.querySelectorAll('a[name]');

    let luaAnchorCount = 0;
    for (const anchor of allAnchors) {
        const anchorName = anchor.getAttribute('name');
        if (anchorName && anchorName.startsWith('lua_')) {
            luaAnchorCount++;
            try {
                const functionDescriptor = parseSpecialLuaFunction(anchor, document);
                if (functionDescriptor) {
                    functions[functionDescriptor.name] = functionDescriptor;
                }
            } catch (error) {
                console.warn(`Failed to parse special Lua function ${anchorName}: ${error}`);
            }
        }
    }

    console.log(`Parsed ${Object.keys(functions).length} special Lua functions out of ${luaAnchorCount} anchors`);

    return functions;
}

function parseSpecialLuaFunction(anchor: Element, document: Document): FunctionDescriptor | null {
    const anchorName = anchor.getAttribute('name');
    if (!anchorName || !anchorName.startsWith('lua_')) {
        return null;
    }

    // Get all text content after the anchor until the next anchor
    let textContent = '';
    let sibling = anchor.nextSibling;

    while (sibling) {
        if (sibling.nodeType === document.defaultView!.Node.ELEMENT_NODE) {
            const element = sibling as Element;

            // Stop if we hit the next anchor
            if (element.tagName === 'A' && element.getAttribute('name')) {
                break;
            }

            textContent += element.textContent || '';
        } else if (sibling.nodeType === document.defaultView!.Node.TEXT_NODE) {
            textContent += sibling.textContent || '';
        }

        sibling = sibling.nextSibling;
    }

    // Look for function signatures - handle multiple patterns
    let codeElement: Element | null = null;
    let signature = '';

    // Pattern 1: Look for {reaper.array} methods
    const arrayMethodMatches = textContent.match(/\{reaper\.array\}\.\w+\([^)]*\)/g);
    if (arrayMethodMatches && arrayMethodMatches.length > 0) {
        signature = arrayMethodMatches[0];
        codeElement = { textContent: signature } as Element;
    }
    // Pattern 2: Look for reaper.functionName() or gfx.functionName()
    else {
        const functionMatches = textContent.match(/(reaper|gfx)\.\w+\([^)]*\)/g);
        if (functionMatches && functionMatches.length > 0) {
            signature = functionMatches[0];
            codeElement = { textContent: signature } as Element;
        }
    }

    // Look for return value assignment lines
    let returnLine: string | null = null;
    const lines = textContent.split(/\r?\n/);
    for (const line of lines) {
        const trimmedLine = line.trim();
        if (trimmedLine.includes(' = reaper.') || trimmedLine.includes(' = gfx.')) {
            returnLine = trimmedLine;
            break;
        }
    }

    // Extract description (text after the function signature)
    let description = '';
    const descMatch = textContent.match(/(?:Returns?|Draws?|Gets?|Sets?|Adds?|Copies?|Converts?)[^<]*[.!]?/);
    if (descMatch) {
        description = cleanDescriptionText(descMatch[0]);
    }

    if (!codeElement) {
        return null;
    }

    if (!signature) {
        signature = codeElement.textContent?.trim() || '';
    }

    if (!signature) {
        return null;
    }

    // Parse function name and parameters
    // Handle reaper.functionName(), gfx.functionName(), and {reaper.array}.methodName() formats
    let functionMatch = signature.match(/(reaper|gfx)\.(\w+)\s*\((.*?)\)/);
    let isArrayMethod = false;

    // Check for {reaper.array} methods
    if (!functionMatch) {
        const arrayMethodMatch = signature.match(/\{reaper\.array\}\.(\w+)\s*\((.*?)\)/);
        if (arrayMethodMatch && arrayMethodMatch[1] && arrayMethodMatch[2] !== undefined) {
            functionMatch = ['', 'ReaperArray', arrayMethodMatch[1], arrayMethodMatch[2]];
            isArrayMethod = true;
        }
    }

    if (!functionMatch || !functionMatch[2] || functionMatch[3] === undefined) {
        return null;
    }

    const prefix = functionMatch[1]; // 'reaper', 'gfx', or 'ReaperArray'
    const functionName = functionMatch[2];
    const fullFunctionName = isArrayMethod ? `${functionName}` : `${prefix}.${functionName}`;
    const parametersString = functionMatch[3].trim();

    // Parse parameters
    let parameters = isArrayMethod ? parseArrayMethodParameters(parametersString, functionName) : parseParameters(parametersString);

    // Parse return types from the return line if available
    let returns = parseSpecialLuaReturnTypes(returnLine, signature);

    // Special handling for reaper.new_array to ensure correct signature
    if (fullFunctionName === 'reaper.new_array') {
        parameters = [
            {
                name: 'table_or_array',
                value: '',
                type: 'table|any[]',
                required: false
            },
            {
                name: 'size',
                value: '',
                type: 'integer',
                required: false
            }
        ];
        returns = [
            {
                name: 'return',
                value: '',
                type: 'ReaperArray',
                required: true
            }
        ];
    }

    // Special handling for ReaperArray methods - add implicit self parameter
    if (isArrayMethod) {
        parameters.unshift({
            name: 'self',
            value: '',
            type: 'ReaperArray',
            required: true
        });
    }

    // Get description from the content after the function
    if (!description) {
        description = getSpecialLuaDescription(anchor, document);
    }

    return {
        name: fullFunctionName,
        description,
        parameters,
        returns
    };
}

function parseSpecialLuaReturnTypes(returnLine: string | null, signature: string): FunctionArgument[] {
    if (!returnLine) {
        return [];
    }

    // Extract the left side of the assignment (return values)
    // Example: "is_new_value,filename,sectionID,cmdID,mode,resolution,val,contextstr = reaper.get_action_context()"
    const assignmentMatch = returnLine.match(/^([^=]+)\s*=\s*/);
    if (!assignmentMatch || !assignmentMatch[1]) {
        return [];
    }

    const returnVarsString = assignmentMatch[1].trim();
    const returnVars = returnVarsString.split(',').map(v => v.trim()).filter(v => v);

    // Map variable names to likely types based on naming conventions
    return returnVars.map(varName => ({
        name: 'return',
        value: '',
        type: inferTypeFromVariableName(varName),
        required: true
    }));
}

function inferTypeFromVariableName(varName: string): string {
    // Type inference based on variable naming conventions
    if (varName.includes('filename') || varName.includes('str') || varName.includes('name') || varName.includes('context')) {
        return 'string';
    }
    if (varName.includes('ID') || varName.includes('mode') || varName.includes('resolution') || varName.includes('val')) {
        return 'integer';
    }
    if (varName.includes('is_') || varName.includes('_new_')) {
        return 'boolean';
    }
    if (varName.includes('x') || varName.includes('y') || varName.includes('w') || varName.includes('h') || varName.includes('r') || varName.includes('g') || varName.includes('b')) {
        return 'number';
    }

    // Default to generic types
    return 'any';
}

function getSpecialLuaDescription(anchor: Element, document: Document): string {
    // The description should be right after the anchor element
    let current = anchor;
    let description = '';

    // Start looking from the element after the anchor
    let nextElement = current.nextSibling;
    let attempts = 0;

    while (nextElement && attempts < 15) {
        attempts++;

        if (nextElement.nodeType === document.defaultView!.Node.TEXT_NODE) {
            const text = nextElement.textContent?.trim();
            if (text && text.length > 10 && !text.includes('Lua:') && !text.includes('EEL2:')) {
                description += text + ' ';
            }
        } else if (nextElement.nodeType === document.defaultView!.Node.ELEMENT_NODE) {
            const element = nextElement as Element;

            // Stop if we hit the next anchor (next function)
            if (element.tagName === 'A' && element.getAttribute('name')) {
                break;
            }

            // Skip the function signature line (the CODE element with parameters)
            if (element.tagName === 'CODE') {
                nextElement = nextElement.nextSibling;
                continue;
            }

            // Extract description text from BR-separated content
            if (element.tagName === 'BR') {
                // Look for text after BR tags
                let textNode = element.nextSibling;
                if (textNode && textNode.nodeType === document.defaultView!.Node.TEXT_NODE) {
                    const text = textNode.textContent?.trim();
                    if (text && text.length > 10 && !text.includes('Lua:') && !text.includes('EEL2:')) {
                        description += text + ' ';
                        // If we found a good description, we can stop here
                        if (description.trim().length > 30) {
                            break;
                        }
                    }
                }
            } else {
                // Extract text from other elements, but avoid navigation/header text
                const text = element.textContent?.trim();
                if (text && text.length > 10 &&
                    !text.includes('Lua:') && !text.includes('EEL2:') &&
                    !element.tagName.match(/^(A|HR)$/) &&
                    !text.match(/^(Returns?|Sets?|Gets?|Queries?)\s*$/)) {
                    description += text + ' ';
                    // If we found a substantial description, stop looking
                    if (description.trim().length > 50) {
                        break;
                    }
                }
            }
        }

        nextElement = nextElement.nextSibling;
    }

    return cleanDescriptionText(description.trim());
}

function parseArrayMethodParameters(parametersString: string, methodName: string): FunctionArgument[] {
    if (!parametersString || parametersString.trim() === '') {
        return [];
    }

    const parameters: FunctionArgument[] = [];

    // Remove brackets and split by comma
    const cleanParams = parametersString.replace(/[\[\]]/g, '').split(',').map(p => p.trim()).filter(p => p);

    // Define parameter types based on method name and common patterns
    const getParameterType = (paramName: string, methodName: string): string => {
        if (paramName.includes('src') && paramName !== 'srcoffs') return 'ReaperArray|table';
        if (paramName.includes('offs') || paramName.includes('size') || paramName.includes('offset')) return 'integer';
        if (paramName.includes('permute')) return 'boolean';
        if (paramName === 'value') return 'number';
        return 'any';
    };

    // All parameters in ReaperArray methods are optional when in brackets
    const allOptional = parametersString.includes('[');

    for (const paramName of cleanParams) {
        if (!paramName) continue;

        parameters.push({
            name: sanitizeParameterName(paramName),
            value: '',
            type: getParameterType(paramName, methodName),
            required: !allOptional
        });
    }

    return parameters;
}